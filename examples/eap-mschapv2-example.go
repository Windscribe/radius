package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/Windscribe/radius"
)

type radiusService struct{}

// The following implements the RADIUS + EAP + MSCHAPV2/MPEEV2 flow for authenticating strongswan clients
// The flow is as follows:

// Peer                   Authenticator
// ----                   -------------
//                        <- EAP-Request/Identity //This is handles by strongswan
// EAP-Response/
// Identity (MyID) ->
//                        <- EAP-Request/
//                           EAP-Type=EAP MS-CHAP-V2 (Challenge) // The challenge is stored by the Identifier for later use
// EAP-Response/
// EAP-Type=EAP-MS-CHAP-V2
// (Response)->
//                        <- EAP-Request/
//                           EAP-Type=EAP-MS-CHAP-V2 (Success) // Upon validating the response validity, we store the ntResponse to later use in MSK generation
//							 *NOTE* The request must be of type AccessChallenge, since the Success Packet contains a generated hash for the client to verify
// EAP-Response/
// EAP-Type=EAP-MS-CHAP-V2
// (Success) ->
//                        <- EAP-Success // This is the AccessAccept, which must contain the MSK fields and DNS fields (this can provide other fields if needed)

// credentials
var credentials = map[string]string{
	"User": "clientPass",
}

// radius secret
var radisuSecret = "XXXXXXXXXXXXXXXX"

func (p radiusService) RadiusHandle(request *radius.Packet) *radius.Packet {

	// a pretty print of the request.
	fmt.Printf("[Authenticate]\n%s\n", request.String())

	eapMessage := request.GetEAPMessage()
	npac := request.Reply()

	// Check if this is an EAP message
	if eapMessage != nil {

		fmt.Printf("[EAP-Message] Code: %s\n", radius.EapCode(eapMessage.Code))
		fmt.Printf("[EAP-Message] Type: %s\n", radius.EapType(eapMessage.Type))
		fmt.Printf("[EAP-Message] ID: %d\n", eapMessage.Identifier)
		fmt.Printf("[EAP-Message] Data: %#v\n", eapMessage.Data)

		switch eapMessage.Code {

		// We only really deal with EAP responses
		case radius.EapCodeResponse:

			//Handle Identity messages (this first message in the flow)
			if eapMessage.Type == radius.EapTypeIdentity {

				mschapMessage := radius.MsChapV2ChallengePacket{}

				// GenerateChallenge gets a new Identifier, generates a challenge, and store the challenge in radius.ServerChallenges map
				newIdentifier := mschapMessage.GenerateChallenge(request.GetUsername())
				npac.Code = radius.AccessChallenge

				// We need to respond with an MSCHAPv2 Request message with the new Identifier and provide the challenge
				eapMessage.Type = radius.EapTypeMSCHAPV2
				eapMessage.Code = radius.EapCodeRequest
				eapMessage.Identifier = newIdentifier

				msPkt := radius.MsChapV2Packet{
					Eap:    eapMessage,
					OpCode: radius.MsChapV2OpCodeChallenge,
					Data:   mschapMessage.Encode(),
				}

				eapMessage.Data = msPkt.Encode()

				npac.AddAVP(radius.AVP{
					Type:  radius.EAPMessage,
					Value: eapMessage.Encode(),
				})

				fmt.Println("Sending EAP Challenge")
				return npac

			}

			// Handle challenge response messages
			if eapMessage.Type == radius.EapTypeMSCHAPV2 {

				// MSCHAPv2 type messages could be in response to the regular Challenge EAP message, or, to the Success Packet

				fmt.Println("Got EapTypeMSCHAPV2 packet!")

				// check the ID, if ServerChallenges contains 0x3 (success) and EAP data is 0x3, respond with AccessAccept
				// If we have only a value of "3" (Success), this is a response to the Success Packet, which is also an AccessChallenge
				if len(eapMessage.Data) == 1 {

					if challengeSuccess, ok := radius.ServerChallenges[eapMessage.Identifier]; ok {

						// If we have a success in the local state for this Identifier, we should respond with AccessAccept and all required fields for the connection
						if bytes.Compare(challengeSuccess, eapMessage.Data) == 0 {

							// get MSK (Master Session Key) data, which requires 4 fields
							// MSMPPEEncryptionPolicy = 0x0001
							// MSMPPEEncryptionTypes = 0x0006
							// MSMPPESendKey = generated by the radius.Mmpev2 method
							// MSMPPERecvKey = generated by the radius.Mmpev2 method
							if peermsk, ok := radius.PeerMSK[eapMessage.Identifier]; ok {

								//handle MPPEV2
								send, recv := radius.Mmpev2(radisuSecret, peermsk["password"], []byte(request.Authenticator[:]), peermsk["resp"])

								// This is a success mschapv2 packet
								fmt.Printf("Sending AccessAccept \n")
								npac.Code = radius.AccessAccept

								npac.AddAVP(radius.AVP{
									Type:  radius.UserName,
									Value: []byte(request.GetUsername()),
								})

								// Set any final attributes, i.e. Primary DNS Server
								// npac.AddVSA(radius.VSA{
								// 	Vendor: radius.Microsoft,
								// 	Type:   28, //28 for MS-Primary-DNS-Server
								// 	Value:  []byte{10, 0, 0, 1},
								// })

								// Set the MSMPPE attributes to establish MSK
								npac.AddVSA(radius.VSA{
									Vendor: radius.Microsoft,
									Type:   radius.MSMPPEEncryptionPolicy,
									Value:  []byte{0x0, 0x0, 0x0, 0x01},
								})
								npac.AddVSA(radius.VSA{
									Vendor: radius.Microsoft,
									Type:   radius.MSMPPEEncryptionTypes,
									Value:  []byte{0x0, 0x0, 0x0, 0x06},
								})
								npac.AddVSA(radius.VSA{
									Vendor: radius.Microsoft,
									Type:   radius.MSMPPESendKey,
									Value:  send,
								})
								npac.AddVSA(radius.VSA{
									Vendor: radius.Microsoft,
									Type:   radius.MSMPPERecvKey,
									Value:  recv,
								})

								//reset identifer data
								radius.ServerChallenges[eapMessage.Identifier] = []byte{}
								radius.PeerMSK[eapMessage.Identifier] = map[string][]byte{}

								fmt.Println("Sending Access-Accept")

								return npac

							}
						}
					}

					// log error send access reject
					fmt.Println("Sending Access-Reject")
					npac.Code = radius.AccessReject
					return npac

				}

				//decode response packet
				respPkt := radius.DecodeMsChapV2Response(eapMessage.Data)

				//get auth challenge for this identifier
				if authChallenge, ok := radius.ServerChallenges[eapMessage.Identifier]; ok {

					username := request.GetUsername()
					fmt.Printf("DEBUG username: (%d) %+v\n", len(username), username)

					// Here you would not use the local credentials map, but call your datasource for the password
					if password, ok := credentials[username]; ok {

						// check validity of the NTResponse using the password
						passwordHash := radius.NtPasswordHash(radius.NTPassword(password))
						valid := radius.CheckResponseValidity(respPkt.NTResponse, authChallenge, respPkt.PeerChallenge, username, passwordHash)

						if valid {

							//generate success response
							response := radius.GenerateAuthenticatorResponse(passwordHash, respPkt.NTResponse, respPkt.PeerChallenge, authChallenge, username)

							npac.Code = radius.AccessChallenge

							msPkt := radius.MsChapV2SuccessPacket{
								Eap:        eapMessage,
								OpCode:     radius.MsChapV2OpCodeSuccess,
								Identifier: eapMessage.Identifier,
								Data:       []byte(response),
							}

							// We need to increment the Identifier for the new challenge request
							eapMessage.Identifier = radius.NextIdentifier()
							eapMessage.Type = radius.EapTypeMSCHAPV2
							eapMessage.Code = radius.EapCodeRequest
							// Set the MsChap Opcode so that we format the packet length correctly
							eapMessage.OpCode = radius.MsChapV2OpCodeSuccess
							eapMessage.Data = msPkt.Encode()

							eapPkt := eapMessage.Encode()
							npac.AddAVP(radius.AVP{
								Type:  radius.EAPMessage,
								Value: eapPkt,
							})

							//set the challenge to success
							radius.ServerChallenges[eapMessage.Identifier] = []byte{0x3}

							//save MSK data so that we can respond with it when get get the Success (0x3) response back
							radius.PeerMSK[eapMessage.Identifier] = map[string][]byte{
								"password": passwordHash,
								"resp":     respPkt.NTResponse,
							}

							fmt.Println("Sending EAP Success Packet in RADIUS Access-Challenge")
							return npac

						}

						// reject
						npac.Code = radius.AccessReject

						eapMessage.Type = radius.EapTypeMSCHAPV2
						eapMessage.Code = radius.EapCodeRequest

						//failChallenge, _ := radius.RandomBytes(32)

						msPkt := radius.MsChapV2SuccessPacket{
							Eap:    eapMessage,
							OpCode: radius.MsChapV2OpCodeFailure,
							Data:   []byte("E=691 R=0"),
						}

						eapMessage.Data = msPkt.Encode()

						eapPkt := eapMessage.Encode()
						npac.AddAVP(radius.AVP{
							Type:  radius.EAPMessage,
							Value: eapPkt,
						})

						fmt.Println("Sending Failure Packet in Access-Reject")
						return npac

					}

				}
			}
		}

	}

	// If we got here, this is not an EAP conversation
	switch request.Code {
	case radius.AccessRequest:
		// check username and password
		fmt.Printf("[DEBUG] %s / %s\n", request.GetUsername(), request.GetPassword())

		// Do your credential checks here and set the response code and attributes appropriately

		// npac.Code = radius.AccessAccept
		// pac.AddVSA(radius.VSA{Vendor: 9, Type: 23, Value: []byte("10.20.30.40")})
		// or
		// npac.Code = radius.AccessReject
		// npac.AddAVP(radius.AVP{Type: radius.ReplyMessage, Value: []byte("Denied!")})

		npac.Code = radius.AccessAccept

	case radius.AccountingRequest:
		// accounting start or end
		npac.Code = radius.AccountingResponse
	default:
		npac.Code = radius.AccessReject
	}
	fmt.Printf("last return packet:\n %+v\n", npac.String())
	return npac
}

func main() {
	s := radius.NewServer("127.0.0.1:1812", radisuSecret, radiusService{})

	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)
	errChan := make(chan error)
	go func() {
		fmt.Println("waiting for packets...")
		err := s.ListenAndServe()
		if err != nil {
			errChan <- err
		}
	}()
	select {
	case <-signalChan:
		log.Println("stopping server...")
		s.Stop()
	case err := <-errChan:
		log.Printf("[ERR] %v", err.Error())
	}
}
